import {ILoadOrder} from '../types/ILoadOrder';

import * as Promise from 'bluebird';
import * as fs from 'fs-extra-promise';
import {decode, encode} from 'iconv-lite';
import {log, types} from 'nmm-api';
import * as path from 'path';

export type PluginFormat = 'original' | 'fallout4';

/**
 * persistor syncing to and from the gamebryo plugins.txt and loadorder.txt
 * 
 * @class PluginPersistor
 * @implements {types.IPersistor}
 */
class PluginPersistor implements types.IPersistor {
  private mPluginPath: string;
  private mPluginFormat: PluginFormat;
  private mResetCallback: () => void;

  private mWatch: fs.FSWatcher;
  private mRefreshTimer: NodeJS.Timer;
  private mSerializing: boolean = false;

  private mPlugins: { [name: string]: ILoadOrder };

  constructor() {
    this.mPlugins = {};
  }

  public loadFiles(pluginPath: string, format: PluginFormat) {
    log('info', 'changed reference plugin file', pluginPath);
    this.mPluginPath = pluginPath;
    this.mPluginFormat = format;
    // read the files now and update the store
    this.deserialize();
    // start watching for external changes
    this.startWatch();
  }

  public setResetCallback(cb: () => void) {
    this.mResetCallback = cb;
  }

  public getItem(key: string, cb: (error: Error, result?: string) => void): void {
    cb(null, JSON.stringify(this.mPlugins));
  }

  public setItem(key: string, value: string, cb: (error: Error) => void): void {
    this.mPlugins = JSON.parse(value);
    this.serialize();
  }

  public removeItem(key: string, cb: (error: Error) => void): void {
    delete this.mPlugins[key];
    this.serialize();
  }

  public getAllKeys(cb: (error: Error, keys?: string[]) => void): void {
    cb(null, ['loadOrder']);
  }

  private toPluginList(input: string[]) {
    if (this.mPluginFormat === 'original') {
      return this.toPluginListOriginal(input);
    } else {
      return this.toPluginListFallout4(input);
    }
  }

  private toPluginListOriginal(input: string[]) {
    return input.filter(
        (pluginName: string) => { return this.mPlugins[pluginName].enabled; });
  }

  private toPluginListFallout4(input: string[]) {
    return input.map((name: string) => {
      if (this.mPlugins[name].enabled) {
        return '*' + name;
      } else {
        return name;
      }
    });
  }

  private serialize(): Promise<void> {
    if (this.mPluginPath === undefined) {
      return;
    }

    this.mSerializing = true;

    let sorted: string[] = Object.keys(this.mPlugins).sort((lhs: string, rhs: string) => {
      return this.mPlugins[lhs].loadOrder - this.mPlugins[rhs].loadOrder;
    });

    return fs.writeFileAsync(path.join(this.mPluginPath, 'loadorder.txt'),
      encode('# Automatically generated by NMM2\r\n' + sorted.join('\r\n'), 'utf-8'))
      .then(() => {
        let filtered: string[] = this.toPluginList(sorted);
        return fs.writeFileAsync(path.join(this.mPluginPath, 'plugins.txt'),
          encode('# Automatically generated by NMM2\r\n' + filtered.join('\r\n'), 'latin-1'));
      })
      .finally(() => {
        this.mSerializing = false;
      })
      ;
  }

  private filterFileData(input: string, plugins: boolean): string[] {
    let res = input.split(/\r?\n/).filter((value: string) => {
        return !value.startsWith('#') && (value.length > 0);
      });

    return res;
  }

  private initFromKeyList(keys: string[], enabled: boolean) {
    let loadOrderPos = Object.keys(this.mPlugins).length;
    keys.forEach((key: string) => {
      let keyEnabled = enabled && ((this.mPluginFormat === 'original') || (key[0] === '*'));
      if ((this.mPluginFormat === 'fallout4') && (key[0] === '*')) {
        key = key.slice(1);
      }
      if (this.mPlugins[key] !== undefined) {
        this.mPlugins[key].enabled = keyEnabled;
      } else {
        this.mPlugins[key] = {
          enabled: keyEnabled,
          loadOrder: loadOrderPos++,
          modIndex: -1,
        };
      }
    });
  }

  private deserialize(): Promise<void> {
    this.mPlugins = {};

    if (this.mPluginPath === undefined) {
      return;
    }

    let phaseOne: Promise<NodeBuffer>;
    if (this.mPluginFormat === 'original') {
      phaseOne = fs.readFileAsync(path.join(this.mPluginPath, 'loadorder.txt'))
                     .then((data: NodeBuffer) => {
                       let keys: string[] =
                           this.filterFileData(decode(data, 'utf-8'), false);
                       this.initFromKeyList(keys, false);
                       return fs.readFileAsync(
                           path.join(this.mPluginPath, 'plugins.txt'));
                     });
    } else {
      phaseOne = fs.readFileAsync(path.join(this.mPluginPath, 'plugins.txt'));
    }
    return phaseOne
    .then((data: NodeBuffer) => {
      let keys: string[] = this.filterFileData(decode(data, 'latin-1'), true);
      this.initFromKeyList(keys, true);
      if (this.mResetCallback) {
        this.mResetCallback();
      }
    })
    .catch((err: Error) => {
      log('warn', 'failed to read plugin file', this.mPluginPath);
    });
  }

  private startWatch() {
    if (this.mWatch !== undefined) {
      this.mWatch.close();
    }
    this.mWatch = fs.watch(this.mPluginPath, {}, (evt, fileName: string) => {
      if (!this.mSerializing && ['loadorder.txt', 'plugins.txt'].indexOf(fileName) !== -1) {
        log('info', 'change event', { evt, fileName });
        if (this.mRefreshTimer !== null) {
          log('info', 'timer canceled');
          clearTimeout(this.mRefreshTimer);
        }
        this.mRefreshTimer = setTimeout(() => {
          log('info', 'refresh timer');
          this.mRefreshTimer = null;
          this.deserialize()
          .then(() => {
            log('info', '/refresh timer');
          });
        }, 500);
      }
    });
  }
}

export default PluginPersistor;
